{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Настройка проекта и базовая структура бота",
        "description": "Создание базовой структуры проекта, установка необходимых зависимостей и настройка Telegram-бота с использованием aiogram.",
        "details": "1. Создать структуру проекта:\n```\n/menu_translator_bot\n  /src\n    __init__.py\n    bot.py\n    config.py\n    handlers.py\n    ocr.py\n    translator.py\n    menu_processor.py\n    html_generator.py\n  .gitignore\n  README.md\n  requirements.txt\n```\n2. Установить зависимости с помощью uv:\n```bash\nuv add aiogram\n```\n3. Создать файл config.py для хранения конфигурационных данных:\n```python\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nBOT_TOKEN = os.getenv('BOT_TOKEN')\nGEMINI_API_KEY = os.getenv('GEMINI_API_KEY')\n```\n4. Создать базовую структуру бота в bot.py:\n```python\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.enums import ParseMode\nfrom config import BOT_TOKEN\n\nbot = Bot(token=BOT_TOKEN)\ndp = Dispatcher()\n\nasync def main():\n    await dp.start_polling(bot)\n\nif __name__ == '__main__':\n    import asyncio\n    from handlers import register_handlers\n    \n    register_handlers(dp)\n    asyncio.run(main())\n```",
        "testStrategy": "1. Проверить успешную инициализацию проекта и установку зависимостей.\n2. Запустить бота и убедиться, что он подключается к Telegram API.\n3. Проверить структуру проекта на соответствие требованиям.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Реализация обработчиков сообщений Telegram",
        "description": "Создание обработчиков для получения фотографий от пользователя и отправки ответов через Telegram API.",
        "details": "1. Создать файл handlers.py с обработчиками сообщений:\n```python\nfrom aiogram import Router, types\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, FSInputFile\nimport os\nfrom bot import bot\nfrom ocr import extract_text_from_image\nfrom translator import detect_language, translate_text\nfrom menu_processor import process_menu\nfrom html_generator import generate_html\n\nrouter = Router()\n\ndef register_handlers(dp):\n    dp.include_router(router)\n\n@router.message(Command('start'))\nasync def cmd_start(message: Message):\n    await message.answer('Привет! Отправь мне фотографию меню на любом языке (кроме русского), и я переведу его для тебя.')\n\n@router.message(Command('help'))\nasync def cmd_help(message: Message):\n    await message.answer('Этот бот переводит меню с фотографии. Просто отправь фото меню, и я верну тебе HTML-файл с переводом.')\n\n@router.message(lambda message: message.photo)\nasync def handle_photo(message: Message):\n    # Сообщаем пользователю, что начали обработку\n    processing_msg = await message.answer('Обрабатываю фотографию меню...')\n    \n    # Получаем фото\n    photo = message.photo[-1]  # Берем самое большое разрешение\n    file_id = photo.file_id\n    file = await bot.get_file(file_id)\n    file_path = file.file_path\n    \n    # Создаем временную директорию, если её нет\n    os.makedirs('temp', exist_ok=True)\n    \n    # Скачиваем фото\n    download_path = f'temp/{file_id}.jpg'\n    await bot.download_file(file_path, download_path)\n    \n    try:\n        # Извлекаем текст\n        await message.answer('Распознаю текст на изображении...')\n        extracted_text = await extract_text_from_image(download_path)\n        \n        if not extracted_text:\n            await message.answer('Не удалось распознать текст на изображении. Пожалуйста, отправьте более четкое фото.')\n            return\n        \n        # Определяем язык\n        language = await detect_language(extracted_text)\n        \n        if language == 'ru':\n            await message.answer('Обнаружен русский язык. Пожалуйста, отправьте меню на другом языке.')\n            return\n        \n        # Обрабатываем меню\n        await message.answer('Анализирую и перевожу меню...')\n        processed_menu = await process_menu(extracted_text, language)\n        \n        # Генерируем HTML\n        html_path = f'temp/{file_id}_menu.html'\n        await generate_html(processed_menu, html_path)\n        \n        # Отправляем результат\n        await message.answer('Вот переведенное меню:')\n        await message.answer_document(FSInputFile(html_path))\n        \n    except Exception as e:\n        await message.answer(f'Произошла ошибка при обработке меню: {str(e)}')\n    finally:\n        # Удаляем временные файлы\n        if os.path.exists(download_path):\n            os.remove(download_path)\n        if os.path.exists(f'temp/{file_id}_menu.html'):\n            os.remove(f'temp/{file_id}_menu.html')\n```",
        "testStrategy": "1. Проверить обработку команд /start и /help.\n2. Проверить обработку фотографий и корректность сообщений о статусе обработки.\n3. Проверить обработку ошибок при отсутствии текста на изображении.\n4. Проверить обработку ошибок при обнаружении русского языка.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Реализация OCR для распознавания текста с изображения",
        "description": "Создание модуля для распознавания текста с фотографии меню с использованием Google Gemini API.",
        "details": "1. Создать файл ocr.py для распознавания текста:\n```python\nimport os\nimport google.generativeai as genai\nfrom config import GEMINI_API_KEY\n\n# Настройка Gemini API\ngenai.configure(api_key=GEMINI_API_KEY)\nmodel = genai.GenerativeModel('gemini-2.0-flash-preview-image-generation')\n\nasync def extract_text_from_image(image_path):\n    \"\"\"\n    Извлекает текст из изображения с помощью Gemini API\n    \"\"\"\n    try:\n        # Загружаем изображение\n        with open(image_path, 'rb') as f:\n            image_data = f.read()\n        \n        # Создаем запрос к модели\n        prompt = \"Extract all text from this menu image. Return only the extracted text without any additional comments.\"\n        \n        # Отправляем запрос с изображением\n        response = model.generate_content(\n            [\n                prompt,\n                {\"mime_type\": \"image/jpeg\", \"data\": image_data}\n            ]\n        )\n        \n        # Получаем результат\n        extracted_text = response.text\n        \n        return extracted_text.strip()\n    except Exception as e:\n        print(f\"Error in OCR: {str(e)}\")\n        return None\n```",
        "testStrategy": "1. Проверить распознавание текста на различных изображениях меню.\n2. Проверить обработку ошибок при некачественных изображениях.\n3. Проверить корректность работы с API Gemini.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Реализация определения языка и перевода текста",
        "description": "Создание модуля для определения языка исходного текста и его перевода на русский язык с использованием Google Gemini API.",
        "details": "1. Создать файл translator.py для определения языка и перевода:\n```python\nimport google.generativeai as genai\nfrom config import GEMINI_API_KEY\n\n# Настройка Gemini API\ngenai.configure(api_key=GEMINI_API_KEY)\nmodel = genai.GenerativeModel('gemini-2.0-flash-preview-image-generation')\n\nasync def detect_language(text):\n    \"\"\"\n    Определяет язык текста с помощью Gemini API\n    \"\"\"\n    try:\n        prompt = f\"Determine the language of the following text. Return only the ISO 639-1 language code (e.g., 'en', 'fr', 'de', etc.):\\n\\n{text}\"\n        \n        response = model.generate_content(prompt)\n        language_code = response.text.strip().lower()\n        \n        return language_code\n    except Exception as e:\n        print(f\"Error in language detection: {str(e)}\")\n        return None\n\nasync def translate_text(text, source_language):\n    \"\"\"\n    Переводит текст на русский язык с помощью Gemini API\n    \"\"\"\n    try:\n        prompt = f\"Translate the following {source_language} text to Russian. Preserve the structure and formatting of the original text:\\n\\n{text}\"\n        \n        response = model.generate_content(prompt)\n        translated_text = response.text.strip()\n        \n        return translated_text\n    except Exception as e:\n        print(f\"Error in translation: {str(e)}\")\n        return None\n```",
        "testStrategy": "1. Проверить определение различных языков (английский, французский, итальянский и т.д.).\n2. Проверить корректность перевода текстов меню на русский язык.\n3. Проверить обработку ошибок при некорректных входных данных.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Реализация обработки и классификации меню",
        "description": "Создание модуля для классификации элементов меню на блюда и напитки, генерации описаний, определения ингредиентов и анализа на наличие молока и глютена.",
        "details": "1. Создать файл menu_processor.py для обработки меню:\n```python\nimport google.generativeai as genai\nfrom config import GEMINI_API_KEY\nfrom translator import translate_text\n\n# Настройка Gemini API\ngenai.configure(api_key=GEMINI_API_KEY)\nmodel = genai.GenerativeModel('gemini-2.0-flash-preview-image-generation')\n\nasync def process_menu(text, source_language):\n    \"\"\"\n    Обрабатывает текст меню: переводит, классифицирует, генерирует описания и анализирует состав\n    \"\"\"\n    try:\n        # Переводим текст на русский\n        translated_text = await translate_text(text, source_language)\n        \n        # Формируем запрос для обработки меню\n        prompt = f\"\"\"\n        Проанализируй следующее меню на русском языке и выполни следующие задачи:\n        \n        1. Классифицируй каждый элемент меню как 'блюдо' или 'напиток'.\n        2. Для каждого блюда (не напитка):\n\n           - Сгенерируй краткое описание блюда на основе его названия\n\n           - Составь список основных ингредиентов\n\n           - Определи, содержит ли блюдо молоко (да/нет/неизвестно)\n\n           - Определи, содержит ли блюдо глютен (да/нет/неизвестно)\n\n        3. Сгруппируй элементы по категориям (закуски, основные блюда, десерты, напитки и т.д.)\n\n        \n        Верни результат в формате JSON со следующей структурой:\n        {{\n            \"categories\": [\n                {{\n                    \"name\": \"Название категории\",\n                    \"items\": [\n                        {{\n                            \"name\": \"Название блюда/напитка\",\n                            \"type\": \"блюдо/напиток\",\n                            \"description\": \"Описание (только для блюд)\",\n                            \"ingredients\": [\"ингредиент1\", \"ингредиент2\", ...] (только для блюд),\n                            \"contains_milk\": \"да/нет/неизвестно\" (только для блюд),\n                            \"contains_gluten\": \"да/нет/неизвестно\" (только для блюд)\n                        }}\n                    ]\n                }}\n            ]\n        }}\n        \n        Меню:\n        {translated_text}\n        \"\"\"\n        \n        response = model.generate_content(prompt)\n        \n        # Предполагаем, что ответ содержит JSON\n        \n        import json\n        \n        try:\n            \n            # Извлекаем JSON из ответа\n            \n            json_str = response.text\n            \n            # Находим начало и конец JSON\n            \n            start_idx = json_str.find('{')\n            \n            end_idx = json_str.rfind('}')\n            \n            if start_idx != -1 and end_idx != -1:\n                \n                json_str = json_str[start_idx:end_idx+1]\n            \n            processed_menu = json.loads(json_str)\n            \n            return processed_menu\n        \n        except json.JSONDecodeError:\n            \n            # Если не удалось распарсить JSON, возвращаем текст как есть\n            \n            return {\"error\": \"Failed to parse menu\", \"raw_response\": response.text}\n    \n    except Exception as e:\n        \n        print(f\"Error in menu processing: {str(e)}\")\n        \n        return {\"error\": str(e)}\n\n\nasync def generate_dish_image(dish_name, description):\n    \"\"\"\n    Генерирует изображение блюда на основе его названия и описания\n    \"\"\"\n    try:\n        prompt = f\"Generate a realistic, appetizing image of the dish: {dish_name}. {description}\"\n        \n        response = model.generate_content(prompt, stream=True)\n        response.resolve()\n        \n        # Извлекаем изображение из ответа\n        \n        for part in response.parts:\n            \n            if hasattr(part, 'parts') and part.parts:\n                \n                for inner_part in part.parts:\n                    \n                    if inner_part.text:\n                        \n                        continue\n                    \n                    if hasattr(inner_part, 'inline_data') and inner_part.inline_data:\n                        \n                        return inner_part.inline_data\n        \n        return None\n    \n    except Exception as e:\n        \n        print(f\"Error in image generation: {str(e)}\")\n        \n        return None\n```",
        "testStrategy": "1. Проверить классификацию различных элементов меню на блюда и напитки.\n2. Проверить генерацию описаний блюд и определение ингредиентов.\n3. Проверить анализ на наличие молока и глютена.\n4. Проверить группировку элементов по категориям.\n5. Проверить генерацию изображений блюд.",
        "priority": "high",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Реализация генерации HTML-страницы с меню",
        "description": "Создание модуля для генерации HTML-документа с отформатированным, переведённым меню, включая изображения блюд и информацию о наличии молока и глютена.",
        "details": "1. Создать файл html_generator.py для генерации HTML-страницы:\n```python\nimport os\nimport base64\nfrom menu_processor import generate_dish_image\n\nasync def generate_html(menu_data, output_path):\n    \"\"\"\n    Генерирует HTML-страницу с переведенным меню\n    \"\"\"\n    try:\n        # Начало HTML-документа\n        html = \"\"\"\n        <!DOCTYPE html>\n        <html lang=\"ru\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <title>Переведенное меню</title>\n            <style>\n                body {\n                    font-family: 'Arial', sans-serif;\n                    max-width: 800px;\n                    margin: 0 auto;\n                    padding: 20px;\n                    background-color: #f9f9f9;\n                }\n                h1 {\n                    text-align: center;\n                    color: #333;\n                    border-bottom: 2px solid #ddd;\n                    padding-bottom: 10px;\n                }\n                h2 {\n                    color: #5a5a5a;\n                    margin-top: 30px;\n                    border-bottom: 1px solid #eee;\n                    padding-bottom: 5px;\n                }\n                .menu-item {\n                    margin-bottom: 20px;\n                    padding: 15px;\n                    background-color: white;\n                    border-radius: 8px;\n                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n                    display: flex;\n                    flex-direction: row;\n                }\n                .menu-item-content {\n                    flex: 1;\n                }\n                .menu-item-image {\n                    width: 150px;\n                    height: 150px;\n                    margin-left: 15px;\n                    object-fit: cover;\n                    border-radius: 5px;\n                }\n                .menu-item h3 {\n                    margin-top: 0;\n                    color: #333;\n                }\n                .menu-item p {\n                    margin: 5px 0;\n                    color: #666;\n                }\n                .ingredients {\n                    font-style: italic;\n                    color: #888;\n                }\n                .allergens {\n                    margin-top: 10px;\n                }\n                .allergen {\n                    display: inline-block;\n                    margin-right: 10px;\n                    font-size: 0.9em;\n                }\n                .yes {\n                    color: #d9534f;\n                }\n                .no {\n                    color: #5cb85c;\n                }\n                .unknown {\n                    color: #f0ad4e;\n                }\n            </style>\n        </head>\n        <body>\n            <h1>Переведенное меню</h1>\n        \"\"\"\n        \n        # Проверяем наличие категорий\n        if \"categories\" in menu_data:\n            for category in menu_data[\"categories\"]:\n                html += f\"<h2>{category['name']}</h2>\\n\"\n                \n                for item in category[\"items\"]:\n                    html += \"<div class='menu-item'>\\n\"\n                    html += \"<div class='menu-item-content'>\\n\"\n                    html += f\"<h3>{item['name']}</h3>\\n\"\n                    \n                    # Если это блюдо (не напиток), добавляем описание и ингредиенты\n                    if item.get(\"type\") == \"блюдо\":\n                        if \"description\" in item and item[\"description\"]:\n                            html += f\"<p>{item['description']}</p>\\n\"\n                        \n                        if \"ingredients\" in item and item[\"ingredients\"]:\n                            ingredients_str = \", \".join(item[\"ingredients\"])\n                            html += f\"<p class='ingredients'><strong>Состав:</strong> {ingredients_str}</p>\\n\"\n                        \n                        # Информация о молоке и глютене\n                        html += \"<div class='allergens'>\\n\"\n                        \n                        milk_status = item.get(\"contains_milk\", \"неизвестно\")\n                        milk_class = \"yes\" if milk_status == \"да\" else \"no\" if milk_status == \"нет\" else \"unknown\"\n                        html += f\"<span class='allergen {milk_class}'>🥛 Молоко: {milk_status}</span>\\n\"\n                        \n                        gluten_status = item.get(\"contains_gluten\", \"неизвестно\")\n                        gluten_class = \"yes\" if gluten_status == \"да\" else \"no\" if gluten_status == \"нет\" else \"unknown\"\n                        html += f\"<span class='allergen {gluten_class}'>🌾 Глютен: {gluten_status}</span>\\n\"\n                        \n                        html += \"</div>\\n\"\n                    \n                    html += \"</div>\\n\"\n                    \n                    # Генерируем изображение для блюда (не для напитков)\n                    if item.get(\"type\") == \"блюдо\":\n                        try:\n                            # Генерируем изображение\n                            image_data = await generate_dish_image(item['name'], item.get('description', ''))\n                            \n                            if image_data:\n                                # Получаем данные изображения и кодируем в base64\n                                mime_type = image_data.mime_type\n                                data = base64.b64encode(image_data.data).decode('utf-8')\n                                img_src = f\"data:{mime_type};base64,{data}\"\n                                html += f\"<img class='menu-item-image' src='{img_src}' alt='{item['name']}'>\\n\"\n                        except Exception as e:\n                            print(f\"Error generating image for {item['name']}: {str(e)}\")\n                    \n                    html += \"</div>\\n\"\n        else:\n            # Если структура не соответствует ожидаемой, выводим сырой ответ\n            html += \"<p>Не удалось обработать меню в ожидаемом формате.</p>\"\n            if \"error\" in menu_data:\n                html += f\"<p>Ошибка: {menu_data['error']}</p>\"\n            if \"raw_response\" in menu_data:\n                html += f\"<pre>{menu_data['raw_response']}</pre>\"\n        \n        # Завершение HTML-документа\n        html += \"\"\"\n        </body>\n        </html>\n        \"\"\"\n        \n        # Записываем HTML в файл\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n        \n        return output_path\n    except Exception as e:\n        print(f\"Error in HTML generation: {str(e)}\")\n        \n        # В случае ошибки создаем простой HTML с сообщением об ошибке\n        error_html = f\"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <meta charset=\"UTF-8\">\n            <title>Ошибка</title>\n        </head>\n        <body>\n            <h1>Произошла ошибка при генерации HTML</h1>\n            <p>{str(e)}</p>\n        </body>\n        </html>\n        \"\"\"\n        \n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(error_html)\n        \n        return output_path\n```",
        "testStrategy": "1. Проверить генерацию HTML-страницы с различными типами меню.\n2. Проверить корректность отображения блюд, напитков, описаний и ингредиентов.\n3. Проверить отображение информации о наличии молока и глютена.\n4. Проверить корректность отображения изображений блюд.\n5. Проверить обработку ошибок при некорректных входных данных.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Интеграция всех компонентов и тестирование полного цикла работы",
        "description": "Интеграция всех разработанных модулей и тестирование полного цикла работы бота от получения фотографии до отправки HTML-файла.",
        "details": "1. Проверить взаимодействие всех модулей:\n   - Получение фотографии через Telegram\n   - Распознавание текста с помощью OCR\n   - Определение языка и перевод текста\n   - Обработка и классификация меню\n   - Генерация HTML-страницы\n   - Отправка HTML-файла пользователю\n\n2. Добавить логирование для отслеживания процесса обработки:\n```python\n# В начало каждого файла добавить:\nimport logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(\"bot.log\"),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n```\n\n3. Добавить обработку ошибок и повторные попытки для критических операций:\n```python\n# Пример функции с повторными попытками\nasync def retry_operation(operation_func, max_retries=3, *args, **kwargs):\n    for attempt in range(max_retries):\n        try:\n            return await operation_func(*args, **kwargs)\n        except Exception as e:\n            logger.error(f\"Attempt {attempt+1}/{max_retries} failed: {str(e)}\")\n            if attempt == max_retries - 1:\n                raise\n            await asyncio.sleep(1)  # Пауза перед повторной попыткой\n```\n\n4. Проверить обработку различных сценариев использования:\n   - Меню на разных языках\n   - Меню с разной структурой\n   - Некачественные фотографии\n   - Фотографии без текста\n   - Фотографии с русским текстом",
        "testStrategy": "1. Провести end-to-end тестирование полного цикла работы бота.\n2. Проверить корректность обработки различных типов меню и языков.\n3. Проверить обработку ошибок и граничных случаев.\n4. Проверить производительность и время отклика бота.\n5. Проверить корректность логирования и отслеживания ошибок.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Оптимизация запросов к модели Gemini",
        "description": "Оптимизация количества обращений к модели Gemini при обработке каждого блюда, чтобы количество обращений было равно единице.",
        "details": "1. Модифицировать функцию process_menu в menu_processor.py для оптимизации запросов:\n```python\nasync def process_menu(text, source_language):\n    \"\"\"\n    Обрабатывает текст меню: переводит, классифицирует, генерирует описания и анализирует состав\n    Оптимизировано для минимизации количества запросов к API\n    \"\"\"\n    try:\n        # Переводим текст на русский\n        translated_text = await translate_text(text, source_language)\n        \n        # Формируем единый запрос для всей обработки меню\n        prompt = f\"\"\"\n        Проанализируй следующее меню на русском языке и выполни все задачи за один запрос:\n        \n        1. Классифицируй каждый элемент меню как 'блюдо' или 'напиток'.\n        2. Для каждого блюда (не напитка):\n           - Сгенерируй краткое описание блюда на основе его названия\n           - Составь список основных ингредиентов\n           - Определи, содержит ли блюдо молоко (да/нет/неизвестно)\n           - Определи, содержит ли блюдо глютен (да/нет/неизвестно)\n        3. Сгруппируй элементы по категориям (закуски, основные блюда, десерты, напитки и т.д.)\n        \n        Верни результат в формате JSON со следующей структурой:\n        {{\"categories\": [{{\"name\": \"Название категории\", \"items\": [{{\"name\": \"Название блюда/напитка\", \"type\": \"блюдо/напиток\", \"description\": \"Описание (только для блюд)\", \"ingredients\": [\"ингредиент1\", \"ингредиент2\", ...] (только для блюд), \"contains_milk\": \"да/нет/неизвестно\" (только для блюд), \"contains_gluten\": \"да/нет/неизвестно\" (только для блюд), \"image_prompt\": \"Подробное описание для генерации изображения блюда\" (только для блюд)}}]}}]}}\n        \n        Меню:\n        {translated_text}\n        \"\"\"\n        \n        response = model.generate_content(prompt)\n        \n        # Извлекаем JSON из ответа\n        import json\n        try:\n            json_str = response.text\n            # Находим начало и конец JSON\n            start_idx = json_str.find('{')\n            end_idx = json_str.rfind('}')\n            if start_idx != -1 and end_idx != -1:\n                json_str = json_str[start_idx:end_idx+1]\n            processed_menu = json.loads(json_str)\n            return processed_menu\n        except json.JSONDecodeError:\n            return {\"error\": \"Failed to parse menu\", \"raw_response\": response.text}\n    except Exception as e:\n        print(f\"Error in menu processing: {str(e)}\")\n        return {\"error\": str(e)}\n```\n\n2. Модифицировать функцию generate_dish_image для использования подготовленных промптов:\n```python\nasync def generate_dish_image(dish_name, description, image_prompt=None):\n    \"\"\"\n    Генерирует изображение блюда на основе его названия, описания и специального промпта\n    \"\"\"\n    try:\n        # Используем готовый промпт, если он есть, иначе формируем новый\n        if image_prompt:\n            prompt = image_prompt\n        else:\n            prompt = f\"Generate a realistic, appetizing image of the dish: {dish_name}. {description}\"\n        \n        response = model.generate_content(prompt, stream=True)\n        response.resolve()\n        \n        # Извлекаем изображение из ответа\n        for part in response.parts:\n            if hasattr(part, 'parts') and part.parts:\n                for inner_part in part.parts:\n                    if inner_part.text:\n                        continue\n                    if hasattr(inner_part, 'inline_data') and inner_part.inline_data:\n                        return inner_part.inline_data\n        return None\n    except Exception as e:\n        print(f\"Error in image generation: {str(e)}\")\n        return None\n```\n\n3. Обновить html_generator.py для использования оптимизированных функций:\n```python\n# В функции generate_html изменить часть с генерацией изображения:\nif item.get(\"type\") == \"блюдо\":\n    try:\n        # Используем готовый промпт для изображения, если он есть\n        image_prompt = item.get('image_prompt')\n        image_data = await generate_dish_image(item['name'], item.get('description', ''), image_prompt)\n        \n        if image_data:\n            # Получаем данные изображения и кодируем в base64\n            mime_type = image_data.mime_type\n            data = base64.b64encode(image_data.data).decode('utf-8')\n            img_src = f\"data:{mime_type};base64,{data}\"\n            html += f\"<img class='menu-item-image' src='{img_src}' alt='{item['name']}'>\\n\"\n    except Exception as e:\n        print(f\"Error generating image for {item['name']}: {str(e)}\")\n```",
        "testStrategy": "1. Проверить количество запросов к API Gemini при обработке меню.\n2. Убедиться, что для каждого блюда выполняется только один запрос к API.\n3. Проверить качество результатов после оптимизации.\n4. Сравнить время обработки до и после оптимизации.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Улучшение дизайна HTML-страницы и добавление интерактивных элементов",
        "description": "Улучшение дизайна HTML-страницы с меню, добавление интерактивных элементов и адаптивности для различных устройств.",
        "details": "1. Обновить CSS-стили в функции generate_html:\n```css\nbody {\n    font-family: 'Roboto', 'Arial', sans-serif;\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 20px;\n    background-color: #f9f9f9;\n    color: #333;\n    line-height: 1.6;\n}\n\nh1 {\n    text-align: center;\n    color: #2c3e50;\n    border-bottom: 2px solid #ecf0f1;\n    padding-bottom: 15px;\n    margin-bottom: 30px;\n    font-weight: 300;\n    font-size: 2.5em;\n}\n\nh2 {\n    color: #3498db;\n    margin-top: 40px;\n    border-bottom: 1px solid #ecf0f1;\n    padding-bottom: 10px;\n    font-weight: 400;\n    font-size: 1.8em;\n}\n\n.menu-item {\n    margin-bottom: 25px;\n    padding: 20px;\n    background-color: white;\n    border-radius: 10px;\n    box-shadow: 0 3px 10px rgba(0,0,0,0.08);\n    display: flex;\n    flex-direction: row;\n    transition: transform 0.2s, box-shadow 0.2s;\n}\n\n.menu-item:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 5px 15px rgba(0,0,0,0.1);\n}\n\n.menu-item-content {\n    flex: 1;\n}\n\n.menu-item-image {\n    width: 180px;\n    height: 180px;\n    margin-left: 20px;\n    object-fit: cover;\n    border-radius: 8px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n    transition: transform 0.3s;\n}\n\n.menu-item-image:hover {\n    transform: scale(1.05);\n}\n\n.menu-item h3 {\n    margin-top: 0;\n    color: #2c3e50;\n    font-size: 1.4em;\n    font-weight: 500;\n}\n\n.menu-item p {\n    margin: 10px 0;\n    color: #555;\n}\n\n.ingredients {\n    font-style: italic;\n    color: #7f8c8d;\n    margin: 12px 0;\n}\n\n.allergens {\n    margin-top: 15px;\n    display: flex;\n    gap: 15px;\n}\n\n.allergen {\n    display: inline-flex;\n    align-items: center;\n    padding: 5px 10px;\n    border-radius: 20px;\n    font-size: 0.9em;\n    font-weight: 500;\n}\n\n.yes {\n    background-color: #ffebee;\n    color: #e53935;\n}\n\n.no {\n    background-color: #e8f5e9;\n    color: #43a047;\n}\n\n.unknown {\n    background-color: #fff8e1;\n    color: #ffb300;\n}\n\n/* Адаптивность для мобильных устройств */\n@media (max-width: 600px) {\n    .menu-item {\n        flex-direction: column;\n    }\n    \n    .menu-item-image {\n        width: 100%;\n        margin-left: 0;\n        margin-top: 15px;\n    }\n    \n    .allergens {\n        flex-direction: column;\n        gap: 8px;\n    }\n}\n```\n\n2. Добавить интерактивные элементы с JavaScript:\n```javascript\n// Добавить в head HTML-документа\n<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Фильтрация по категориям\n    const categories = document.querySelectorAll('h2');\n    const filterContainer = document.createElement('div');\n    filterContainer.className = 'filter-container';\n    filterContainer.innerHTML = '<h3>Фильтр по категориям:</h3>';\n    \n    const allButton = document.createElement('button');\n    allButton.textContent = 'Все';\n    allButton.className = 'filter-btn active';\n    allButton.onclick = function() {\n        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));\n        this.classList.add('active');\n        document.querySelectorAll('h2, .menu-item').forEach(el => el.style.display = '');\n    };\n    filterContainer.appendChild(allButton);\n    \n    categories.forEach(category => {\n        const button = document.createElement('button');\n        button.textContent = category.textContent;\n        button.className = 'filter-btn';\n        button.onclick = function() {\n            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));\n            this.classList.add('active');\n            \n            document.querySelectorAll('h2, .menu-item').forEach(el => el.style.display = 'none');\n            category.style.display = '';\n            \n            const items = [];\n            let current = category.nextElementSibling;\n            while(current && current.tagName !== 'H2') {\n                if(current.classList.contains('menu-item')) {\n                    current.style.display = '';\n                }\n                current = current.nextElementSibling;\n            }\n        };\n        filterContainer.appendChild(button);\n    });\n    \n    // Фильтр по аллергенам\n    const allergenFilter = document.createElement('div');\n    allergenFilter.className = 'allergen-filter';\n    allergenFilter.innerHTML = `\n        <h3>Фильтр по аллергенам:</h3>\n        <label><input type=\"checkbox\" id=\"milk-free\"> Без молока</label>\n        <label><input type=\"checkbox\" id=\"gluten-free\"> Без глютена</label>\n    `;\n    \n    filterContainer.appendChild(allergenFilter);\n    document.querySelector('h1').after(filterContainer);\n    \n    // Обработчики для фильтров по аллергенам\n    document.getElementById('milk-free').addEventListener('change', filterItems);\n    document.getElementById('gluten-free').addEventListener('change', filterItems);\n    \n    function filterItems() {\n        const milkFree = document.getElementById('milk-free').checked;\n        const glutenFree = document.getElementById('gluten-free').checked;\n        \n        document.querySelectorAll('.menu-item').forEach(item => {\n            let show = true;\n            \n            if(milkFree) {\n                const milkStatus = item.querySelector('.allergen:nth-child(1)');\n                if(milkStatus && milkStatus.textContent.includes('да')) {\n                    show = false;\n                }\n            }\n            \n            if(glutenFree && show) {\n                const glutenStatus = item.querySelector('.allergen:nth-child(2)');\n                if(glutenStatus && glutenStatus.textContent.includes('да')) {\n                    show = false;\n                }\n            }\n            \n            item.style.display = show ? '' : 'none';\n        });\n    }\n});\n</script>\n\n<style>\n.filter-container {\n    margin: 20px 0 30px;\n    padding: 15px;\n    background-color: white;\n    border-radius: 10px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n}\n\n.filter-container h3 {\n    margin-top: 0;\n    color: #2c3e50;\n}\n\n.filter-btn {\n    margin: 5px;\n    padding: 8px 15px;\n    background-color: #ecf0f1;\n    border: none;\n    border-radius: 20px;\n    color: #7f8c8d;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.filter-btn:hover {\n    background-color: #3498db;\n    color: white;\n}\n\n.filter-btn.active {\n    background-color: #2980b9;\n    color: white;\n}\n\n.allergen-filter {\n    margin-top: 15px;\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    gap: 15px;\n}\n\n.allergen-filter label {\n    display: flex;\n    align-items: center;\n    gap: 5px;\n    cursor: pointer;\n}\n</style>\n```\n\n3. Обновить функцию generate_html для включения JavaScript и новых стилей.",
        "testStrategy": "1. Проверить корректность отображения HTML-страницы на различных устройствах (десктоп, планшет, мобильный).\n2. Проверить работу интерактивных элементов: фильтрация по категориям и аллергенам.\n3. Проверить анимации и эффекты при наведении.\n4. Проверить корректность отображения в различных браузерах (Chrome, Firefox, Safari).",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Документация и развертывание",
        "description": "Создание документации по использованию бота, инструкций по установке и настройке, а также подготовка к развертыванию.",
        "details": "1. Создать README.md с описанием проекта и инструкциями:\n```markdown\n# Telegram-бот для распознавания и перевода меню\n\n## Описание\nЭтот Telegram-бот позволяет пользователю отправить фотографию печатного меню (на любом языке, кроме русского), распознает текст, переводит его на русский язык, классифицирует позиции на блюда и напитки. Для каждого блюда определяет состав, наличие молока и глютена. В ответ пользователь получает HTML-страницу с красиво оформленным переведённым меню.\n\n## Функциональность\n- Получение фото меню от пользователя через Telegram\n- Распознавание текста на фото\n- Определение языка исходного текста (исключение — русский)\n- Перевод текста на русский язык\n- Классификация элементов меню: блюда и напитки\n- Для каждого блюда (не напитки):\n  - Генерация описания блюда на основе его полного наименования\n  - Генерация списка ингредиентов\n  - Генерация изображения блюда на основе его описания\n  - Определение наличия молока (да/нет/неизвестно)\n  - Определение наличия глютена (да/нет/неизвестно)\n- Генерация HTML-документа с отформатированным, переведённым меню\n- Отправка HTML-файла пользователю\n\n## Требования\n- Python 3.11+\n- uv (менеджер пакетов)\n\n## Установка\n\n1. Клонировать репозиторий:\n```bash\ngit clone https://github.com/username/menu-translator-bot.git\ncd menu-translator-bot\n```\n\n2. Установить зависимости с помощью uv:\n```bash\nuv add aiogram\nuv add python-dotenv\n```\n\n3. Создать файл .env в корневой директории проекта и добавить следующие переменные:\n```\nBOT_TOKEN=your_telegram_bot_token\nGEMINI_API_KEY=your_gemini_api_key\n```\n\n## Запуск\n\n```bash\nuv run python src/bot.py\n```\n\n## Использование\n\n1. Найдите бота в Telegram по его имени пользователя\n2. Отправьте фотографию меню (на любом языке, кроме русского)\n3. Дождитесь ответа с HTML-файлом переведенного меню\n\n## Структура проекта\n\n```\n/menu_translator_bot\n  /src\n    __init__.py\n    bot.py - основной файл бота\n    config.py - конфигурационные данные\n    handlers.py - обработчики сообщений\n    ocr.py - распознавание текста\n    translator.py - определение языка и перевод\n    menu_processor.py - обработка и классификация меню\n    html_generator.py - генерация HTML-страницы\n  .gitignore\n  README.md\n  requirements.txt\n```\n\n## Лицензия\nMIT\n```\n\n2. Создать файл .env.example с примером переменных окружения:\n```\nBOT_TOKEN=your_telegram_bot_token\nGEMINI_API_KEY=your_gemini_api_key\n```\n\n3. Создать файл requirements.txt для установки зависимостей:\n```\naiogram>=3.0.0\npython-dotenv>=1.0.0\n```\n\n4. Создать файл Dockerfile для контейнеризации:\n```dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Установка uv\nRUN pip install uv\n\n# Копирование файлов проекта\nCOPY . .\n\n# Установка зависимостей с помощью uv\nRUN uv pip install -r requirements.txt\n\n# Запуск бота\nCMD [\"python\", \"src/bot.py\"]\n```\n\n5. Создать файл docker-compose.yml для упрощения развертывания:\n```yaml\nversion: '3'\n\nservices:\n  bot:\n    build: .\n    restart: always\n    env_file:\n      - .env\n    volumes:\n      - ./temp:/app/temp\n```",
        "testStrategy": "1. Проверить корректность и полноту документации.\n2. Проверить инструкции по установке и настройке.\n3. Проверить развертывание с использованием Docker.\n4. Проверить работу бота после развертывания.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-29T11:49:52.623Z",
      "updated": "2025-07-29T12:33:35.431Z",
      "description": "Tasks for master context"
    }
  }
}