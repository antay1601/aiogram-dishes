{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Настройка базовой структуры проекта",
        "description": "Создание базовой структуры проекта, установка необходимых зависимостей и настройка окружения для разработки Telegram-бота.",
        "details": "1. Создать репозиторий проекта\n2. Настроить структуру каталогов:\n   - `/src` - основной код\n   - `/tests` - тесты\n   - `/resources` - ресурсы\n3. Создать файл `requirements.txt` с минимальными зависимостями:\n   - aiogram\n   - python-dotenv (для управления переменными окружения)\n4. Создать файл `.env` для хранения API-ключей:\n   - TELEGRAM_BOT_TOKEN\n   - GEMINI_API_KEY\n5. Настроить `.gitignore` для исключения виртуального окружения и файлов с секретами\n6. Создать базовый файл `main.py` с инициализацией бота\n7. Использовать менеджер пакетов uv для установки зависимостей: `uv add aiogram python-dotenv`\n8. Создать README.md с описанием проекта и инструкциями по установке",
        "testStrategy": "Проверить корректность структуры проекта, убедиться, что все зависимости устанавливаются без ошибок с помощью uv, проверить, что файл .env корректно загружается и переменные окружения доступны в приложении.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Реализация базовой функциональности Telegram-бота",
        "description": "Создание основной структуры Telegram-бота с использованием aiogram, настройка обработчиков команд и получения фотографий от пользователя.",
        "details": "1. Инициализировать бот с использованием aiogram 3.x:\n```python\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.types import Message\nfrom aiogram.filters import Command\n\nbot = Bot(token=os.getenv('TELEGRAM_BOT_TOKEN'))\ndp = Dispatcher()\n```\n2. Создать обработчики для команд:\n   - `/start` - приветствие и инструкция по использованию\n   - `/help` - справка по функциональности\n3. Реализовать обработчик для получения фотографий:\n```python\n@dp.message(F.photo)\nasync def handle_photo(message: Message):\n    # Получение фото с наилучшим качеством\n    photo = message.photo[-1]\n    file_id = photo.file_id\n    file = await bot.get_file(file_id)\n    file_path = file.file_path\n    # Скачивание фото\n    await bot.download_file(file_path, 'temp_menu.jpg')\n    await message.reply('Фото получено, начинаю обработку...')\n    # Здесь будет вызов функции обработки меню\n```\n4. Добавить обработку ошибок и логирование\n5. Настроить запуск бота:\n```python\nasync def main():\n    await dp.start_polling(bot)\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```",
        "testStrategy": "Проверить работу бота в тестовом режиме: запуск, ответ на команды /start и /help, получение и сохранение фотографий. Убедиться, что бот корректно обрабатывает ошибки и не падает при неожиданных входных данных.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Реализация OCR для распознавания текста с фотографии",
        "description": "Разработка модуля для распознавания текста с фотографии меню с использованием возможностей Gemini 2.5 Pro.",
        "details": "1. Создать модуль `ocr.py` для распознавания текста\n2. Реализовать функцию для обработки изображения и извлечения текста с помощью Gemini 2.5 Pro:\n```python\nasync def extract_text_from_image(image_path):\n    # Загрузка изображения\n    with open(image_path, 'rb') as f:\n        image_data = f.read()\n    \n    # Подготовка запроса к Gemini API\n    gemini = GeminiAPI(api_key=os.getenv('GEMINI_API_KEY'))\n    \n    # Запрос на распознавание текста\n    prompt = \"Распознай весь текст с этого изображения меню. Верни только распознанный текст без дополнительных комментариев.\"\n    response = await gemini.generate_content(\n        prompt=prompt,\n        image=image_data\n    )\n    \n    # Возвращаем распознанный текст\n    return response.text\n```\n3. Создать класс-обертку для работы с Gemini API:\n```python\nclass GeminiAPI:\n    def __init__(self, api_key):\n        self.api_key = api_key\n        self.base_url = \"https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent\"\n        \n    async def generate_content(self, prompt, image=None):\n        # Реализация запроса к API\n        # ...\n```\n4. Добавить обработку ошибок и повторные попытки при сбоях API",
        "testStrategy": "Подготовить набор тестовых изображений меню на разных языках и проверить качество распознавания текста. Проверить обработку ошибок при плохом качестве изображения или отсутствии текста на нем. Написать юнит-тесты для проверки функциональности модуля OCR.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Определение языка и валидация исходного текста",
        "description": "Разработка модуля для определения языка распознанного текста и проверки, что текст не на русском языке.",
        "details": "1. Создать модуль `language_detection.py`\n2. Реализовать функцию для определения языка с использованием Gemini 2.5 Pro:\n```python\nasync def detect_language(text):\n    gemini = GeminiAPI(api_key=os.getenv('GEMINI_API_KEY'))\n    \n    prompt = \"Определи язык следующего текста. Верни только код языка (например, 'en', 'fr', 'de' и т.д.):\\n\\n\" + text\n    \n    response = await gemini.generate_content(prompt=prompt)\n    language_code = response.text.strip().lower()\n    \n    return language_code\n```\n3. Реализовать функцию для проверки, что текст не на русском языке:\n```python\nasync def validate_non_russian(text):\n    language_code = await detect_language(text)\n    \n    if language_code == 'ru':\n        return False, \"Меню на русском языке. Пожалуйста, отправьте меню на другом языке.\"\n    \n    return True, language_code\n```\n4. Добавить обработку случаев, когда текст содержит смесь языков или язык не может быть определен однозначно",
        "testStrategy": "Подготовить тестовые примеры текстов на разных языках, включая русский, и проверить корректность определения языка. Проверить обработку случаев с текстами на нескольких языках. Написать юнит-тесты для проверки функциональности модуля определения языка.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Перевод текста меню на русский язык",
        "description": "Разработка модуля для перевода распознанного текста меню на русский язык с использованием Gemini 2.5 Pro.",
        "details": "1. Создать модуль `translation.py`\n2. Реализовать функцию для перевода текста на русский язык:\n```python\nasync def translate_to_russian(text, source_language):\n    gemini = GeminiAPI(api_key=os.getenv('GEMINI_API_KEY'))\n    \n    prompt = f\"Переведи следующий текст меню с языка {source_language} на русский язык. Сохрани структуру и форматирование меню:\\n\\n{text}\"\n    \n    response = await gemini.generate_content(prompt=prompt)\n    translated_text = response.text\n    \n    return translated_text\n```\n3. Добавить обработку специфических кулинарных терминов и названий блюд:\n```python\nasync def translate_menu_with_context(text, source_language):\n    gemini = GeminiAPI(api_key=os.getenv('GEMINI_API_KEY'))\n    \n    prompt = f\"\"\"Переведи следующее меню с языка {source_language} на русский язык. Учитывай следующие правила:\n    1. Сохрани структуру и форматирование меню\n    2. Для названий блюд и кулинарных терминов используй наиболее подходящие русские эквиваленты\n    3. Если блюдо имеет уникальное название, которое не переводится, оставь оригинальное название в скобках\n    4. Сохрани цены и другую числовую информацию\n    \n    Меню для перевода:\\n{text}\"\"\"\n    \n    response = await gemini.generate_content(prompt=prompt)\n    translated_text = response.text\n    \n    return translated_text\n```\n4. Реализовать обработку ошибок и повторные попытки при сбоях API",
        "testStrategy": "Подготовить тестовые примеры меню на разных языках и проверить качество перевода. Особое внимание уделить переводу специфических кулинарных терминов и названий блюд. Проверить сохранение структуры и форматирования меню при переводе. Написать юнит-тесты для проверки функциональности модуля перевода.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Классификация элементов меню на блюда и напитки",
        "description": "Разработка модуля для классификации элементов меню на категории: закуски, основные блюда, напитки и т.д.",
        "details": "1. Создать модуль `classification.py`\n2. Реализовать функцию для разбиения текста меню на отдельные позиции:\n```python\ndef split_menu_into_items(menu_text):\n    # Логика разбиения текста меню на отдельные позиции\n    # Может использовать регулярные выражения или эвристики\n    # ...\n    return menu_items\n```\n3. Реализовать функцию для классификации позиций меню с использованием Gemini 2.5 Pro:\n```python\nasync def classify_menu_items(menu_items):\n    gemini = GeminiAPI(api_key=os.getenv('GEMINI_API_KEY'))\n    classified_items = []\n    \n    for item in menu_items:\n        prompt = f\"\"\"Классифицируй следующую позицию меню по категории (закуска, основное блюдо, десерт, напиток и т.д.). \n        Верни JSON в формате: {{\"item\": \"[текст позиции]\", \"category\": \"[категория]\", \"is_drink\": [true/false]}}.\n        \n        Позиция меню: {item}\"\"\"\n        \n        response = await gemini.generate_content(prompt=prompt)\n        try:\n            classified_item = json.loads(response.text)\n            classified_items.append(classified_item)\n        except json.JSONDecodeError:\n            # Обработка ошибки парсинга JSON\n            classified_items.append({\"item\": item, \"category\": \"неизвестно\", \"is_drink\": False})\n    \n    return classified_items\n```\n4. Реализовать группировку позиций по категориям:\n```python\ndef group_items_by_category(classified_items):\n    grouped_items = {}\n    \n    for item in classified_items:\n        category = item[\"category\"]\n        if category not in grouped_items:\n            grouped_items[category] = []\n        \n        grouped_items[category].append(item)\n    \n    return grouped_items\n```",
        "testStrategy": "Подготовить тестовые примеры меню с разнообразными позициями и проверить корректность классификации. Проверить обработку сложных случаев, когда позиция может относиться к нескольким категориям. Написать юнит-тесты для проверки функциональности модуля классификации.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Анализ состава блюд и определение наличия молока и глютена",
        "description": "Разработка модуля для генерации списка ингредиентов для каждого блюда и определения наличия молока и глютена.",
        "details": "1. Создать модуль `ingredients_analysis.py`\n2. Реализовать функцию для генерации списка ингредиентов с использованием Gemini 2.5 Pro:\n```python\nasync def generate_ingredients_list(dish_name, dish_description=\"\"):\n    gemini = GeminiAPI(api_key=os.getenv('GEMINI_API_KEY'))\n    \n    prompt = f\"\"\"Для следующего блюда сгенерируй список вероятных ингредиентов. \n    Верни JSON в формате: {{\"ingredients\": [\"ингредиент1\", \"ингредиент2\", ...]}}\n    \n    Название блюда: {dish_name}\n    Описание (если есть): {dish_description}\"\"\"\n    \n    response = await gemini.generate_content(prompt=prompt)\n    try:\n        ingredients_data = json.loads(response.text)\n        return ingredients_data[\"ingredients\"]\n    except (json.JSONDecodeError, KeyError):\n        # Обработка ошибки парсинга JSON\n        return []\n```\n3. Реализовать функцию для определения наличия молока и глютена:\n```python\nasync def check_allergens(ingredients):\n    gemini = GeminiAPI(api_key=os.getenv('GEMINI_API_KEY'))\n    \n    ingredients_text = \", \".join(ingredients)\n    prompt = f\"\"\"Проанализируй следующие ингредиенты и определи наличие молока и глютена.\n    Верни JSON в формате: {{\"has_milk\": \"yes/no/unknown\", \"has_gluten\": \"yes/no/unknown\"}}\n    \n    Ингредиенты: {ingredients_text}\"\"\"\n    \n    response = await gemini.generate_content(prompt=prompt)\n    try:\n        allergens_data = json.loads(response.text)\n        return allergens_data\n    except json.JSONDecodeError:\n        # Обработка ошибки парсинга JSON\n        return {\"has_milk\": \"unknown\", \"has_gluten\": \"unknown\"}\n```\n4. Реализовать функцию для анализа всех блюд в меню:\n```python\nasync def analyze_all_dishes(classified_items):\n    analyzed_items = []\n    \n    for item in classified_items:\n        if not item[\"is_drink\"]:\n            ingredients = await generate_ingredients_list(item[\"item\"])\n            allergens = await check_allergens(ingredients)\n            \n            item[\"ingredients\"] = ingredients\n            item[\"has_milk\"] = allergens[\"has_milk\"]\n            item[\"has_gluten\"] = allergens[\"has_gluten\"]\n        else:\n            item[\"ingredients\"] = []\n            item[\"has_milk\"] = \"none\"\n            item[\"has_gluten\"] = \"none\"\n        \n        analyzed_items.append(item)\n    \n    return analyzed_items\n```",
        "testStrategy": "Подготовить тестовые примеры блюд с известным составом и проверить корректность определения ингредиентов и аллергенов. Проверить обработку сложных случаев, когда состав блюда неочевиден. Написать юнит-тесты для проверки функциональности модуля анализа ингредиентов.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Генерация HTML-документа с отформатированным меню",
        "description": "Разработка модуля для создания HTML-страницы с красиво оформленным переведённым меню, сгруппированным по категориям.",
        "details": "1. Создать модуль `html_generator.py`\n2. Реализовать функцию для генерации HTML-документа:\n```python\ndef generate_html_menu(grouped_items):\n    html = \"\"\"<!DOCTYPE html>\n<html lang=\"ru\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Переведенное меню</title>\n    <style>\n        body {\n            font-family: 'Arial', sans-serif;\n            max-width: 800px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f9f9f9;\n        }\n        h1 {\n            text-align: center;\n            color: #333;\n            border-bottom: 2px solid #ddd;\n            padding-bottom: 10px;\n        }\n        h2 {\n            color: #555;\n            margin-top: 30px;\n            border-bottom: 1px solid #eee;\n            padding-bottom: 5px;\n        }\n        .menu-item {\n            margin-bottom: 20px;\n            padding: 15px;\n            background-color: white;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .menu-item h3 {\n            margin-top: 0;\n            color: #333;\n        }\n        .ingredients {\n            font-size: 0.9em;\n            color: #666;\n            margin-top: 10px;\n        }\n        .allergens {\n            margin-top: 10px;\n            font-size: 0.8em;\n        }\n        .allergen-icon {\n            margin-right: 5px;\n        }\n    </style>\n</head>\n<body>\n    <h1>Переведенное меню</h1>\n\"\"\"\n    \n    # Добавление категорий и позиций меню\n    for category, items in grouped_items.items():\n        html += f\"\\n    <h2>{category}</h2>\\n\"\n        \n        for item in items:\n            html += \"    <div class=\\\"menu-item\\\">\\n\"\n            html += f\"        <h3>{item['item']}</h3>\\n\"\n            \n            if not item.get('is_drink', False) and item.get('ingredients'):\n                ingredients_text = \", \".join(item['ingredients'])\n                html += f\"        <div class=\\\"ingredients\\\">Состав: {ingredients_text}</div>\\n\"\n                \n                # Добавление информации об аллергенах\n                html += \"        <div class=\\\"allergens\\\">\\n\"\n                \n                milk_status = item.get('has_milk', 'unknown')\n                if milk_status == 'yes':\n                    html += \"            <span class=\\\"allergen-icon\\\">🥛</span> Содержит молоко\\n\"\n                elif milk_status == 'no':\n                    html += \"            <span class=\\\"allergen-icon\\\">✅</span> Без молока\\n\"\n                \n                gluten_status = item.get('has_gluten', 'unknown')\n                if gluten_status == 'yes':\n                    html += \"            <span class=\\\"allergen-icon\\\">🌾</span> Содержит глютен\\n\"\n                elif gluten_status == 'no':\n                    html += \"            <span class=\\\"allergen-icon\\\">✅</span> Без глютена\\n\"\n                \n                html += \"        </div>\\n\"\n            \n            html += \"    </div>\\n\"\n    \n    html += \"</body>\\n</html>\"\n    \n    return html\n```\n3. Реализовать функцию для сохранения HTML-документа в файл:\n```python\ndef save_html_to_file(html_content, filename=\"translated_menu.html\"):\n    with open(filename, \"w\", encoding=\"utf-8\") as f:\n        f.write(html_content)\n    \n    return filename\n```",
        "testStrategy": "Проверить генерацию HTML-документа с различными наборами данных. Убедиться, что HTML-код валиден и корректно отображается в браузере. Проверить корректное отображение эмодзи и иконок для аллергенов. Написать юнит-тесты для проверки функциональности модуля генерации HTML.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Отправка HTML-файла пользователю через Telegram",
        "description": "Разработка функциональности для отправки сгенерированного HTML-файла пользователю через Telegram-бота.",
        "details": "1. Дополнить модуль обработки сообщений функцией для отправки HTML-файла:\n```python\nasync def send_html_file(chat_id, html_file_path, caption=\"Вот ваше переведенное меню:\"):\n    with open(html_file_path, \"rb\") as file:\n        await bot.send_document(\n            chat_id=chat_id,\n            document=types.BufferedInputFile(\n                file=file.read(),\n                filename=\"menu.html\"\n            ),\n            caption=caption\n        )\n```\n2. Обновить обработчик фотографий для использования всего процесса обработки:\n```python\n@dp.message(F.photo)\nasync def handle_photo(message: Message):\n    # Отправка сообщения о начале обработки\n    processing_msg = await message.reply('Фото получено, начинаю обработку...')\n    \n    try:\n        # Получение и сохранение фото\n        photo = message.photo[-1]\n        file_id = photo.file_id\n        file = await bot.get_file(file_id)\n        file_path = file.file_path\n        photo_path = f\"temp_{message.from_user.id}.jpg\"\n        await bot.download_file(file_path, photo_path)\n        \n        # Распознавание текста\n        await processing_msg.edit_text('Распознаю текст с изображения...')\n        menu_text = await extract_text_from_image(photo_path)\n        \n        if not menu_text.strip():\n            await processing_msg.edit_text('Не удалось распознать текст на изображении. Пожалуйста, отправьте более четкое фото.')\n            return\n        \n        # Определение языка и валидация\n        await processing_msg.edit_text('Определяю язык меню...')\n        is_valid, language_code = await validate_non_russian(menu_text)\n        \n        if not is_valid:\n            await processing_msg.edit_text(language_code)  # language_code содержит сообщение об ошибке\n            return\n        \n        # Перевод текста\n        await processing_msg.edit_text('Перевожу меню на русский язык...')\n        translated_text = await translate_to_russian(menu_text, language_code)\n        \n        # Классификация позиций меню\n        await processing_msg.edit_text('Классифицирую позиции меню...')\n        menu_items = split_menu_into_items(translated_text)\n        classified_items = await classify_menu_items(menu_items)\n        \n        # Анализ состава и аллергенов\n        await processing_msg.edit_text('Анализирую состав блюд...')\n        analyzed_items = await analyze_all_dishes(classified_items)\n        \n        # Группировка по категориям\n        grouped_items = group_items_by_category(analyzed_items)\n        \n        # Генерация HTML\n        await processing_msg.edit_text('Создаю HTML-документ...')\n        html_content = generate_html_menu(grouped_items)\n        html_file_path = save_html_to_file(html_content, f\"menu_{message.from_user.id}.html\")\n        \n        # Отправка файла пользователю\n        await processing_msg.edit_text('Готово! Отправляю результат...')\n        await send_html_file(message.chat.id, html_file_path)\n        \n        # Удаление временных файлов\n        os.remove(photo_path)\n        os.remove(html_file_path)\n        \n    except Exception as e:\n        logging.error(f\"Error processing photo: {e}\")\n        await processing_msg.edit_text(f'Произошла ошибка при обработке фото: {str(e)}')\n```",
        "testStrategy": "Проверить полный процесс обработки фотографии меню от получения до отправки HTML-файла. Убедиться, что пользователь получает информативные сообщения о ходе обработки. Проверить обработку различных ошибок, которые могут возникнуть в процессе. Провести интеграционное тестирование всего процесса с реальными фотографиями меню.",
        "priority": "high",
        "dependencies": [
          2,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Оптимизация и финальное тестирование",
        "description": "Оптимизация производительности, улучшение обработки ошибок, добавление логирования и проведение финального тестирования всего приложения.",
        "details": "1. Добавить подробное логирование во все модули:\n```python\nimport logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(\"bot.log\"),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n```\n2. Оптимизировать запросы к Gemini API:\n   - Добавить кэширование результатов для одинаковых запросов\n   - Реализовать механизм повторных попыток с экспоненциальной задержкой\n   - Добавить ограничение на количество одновременных запросов\n3. Улучшить обработку ошибок:\n   - Добавить более информативные сообщения об ошибках для пользователя\n   - Реализовать механизм восстановления после сбоев\n   - Добавить мониторинг состояния приложения\n4. Оптимизировать использование памяти:\n   - Удалять временные файлы после использования\n   - Использовать потоковую обработку данных, где это возможно\n5. Добавить метрики производительности:\n   - Время обработки каждого этапа\n   - Общее время обработки запроса\n   - Количество успешных и неуспешных запросов\n6. Провести нагрузочное тестирование:\n   - Проверить работу бота при одновременной обработке нескольких запросов\n   - Измерить время отклика при различной нагрузке\n7. Добавить документацию к коду и README.md с описанием архитектуры и инструкциями по развертыванию",
        "testStrategy": "Провести комплексное тестирование всего приложения с различными типами входных данных. Проверить корректность обработки ошибок и восстановления после сбоев. Измерить производительность и время отклика при различной нагрузке. Провести тестирование с реальными пользователями для получения обратной связи.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-28T11:42:35.075Z",
      "updated": "2025-07-28T11:42:35.075Z",
      "description": "Tasks for master context"
    }
  }
}